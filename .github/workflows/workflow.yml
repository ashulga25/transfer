name: CI Pipeline

on:
  push:
    branches:
    - main
    - feature/*
  pull_request:
    branches:
    - main
# defined in the job below
# Permissions required for OIDC token generation
# permissions:
#   id-token: write
#   contents: read

env:
  ACR_NAME: ${{ secrets.ACR_NAME }}
  RESOURCE_GROUP: ${{ secrets.RESOURCE_GROUP}}
  WEBAPP_NAME: ${{ secrets.WEBAPP_NAME }}
  
  APP_NAME:  ${{ vars.APP_NAME }}
  ACR_REPO_NAME: ${{ vars.ACR_REPO_NAME }}
  
jobs:
  test-and-build:
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.set-image-tag.outputs.image_tag }}
    steps:
    # Checkout the repository
    - name: Checkout code
      uses: actions/checkout@v4

    # Set up Python
    - name: Set up Python 3.13
      uses: actions/setup-python@v5
      with:
        python-version: 3.13

    # Install dependencies for testing
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    # Run pytest tests
    - name: Run tests
      run: pytest test_main.py

    # Set up Docker Buildx
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Build Docker image
    - name: Build Docker image
      run: |
        docker build -t ${{ env.APP_NAME }}:${{ github.sha }} .

    # Save image tag as output
    - name: Set image tag
      id: set-image-tag
      run: echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT

    # Save Docker image as artifact
    - name: Save Docker image
      run: |
        docker save ${{env.APP_NAME}}:${{ github.sha }} | gzip > image.tar.gz

    # Upload Docker image artifact
    - name: Upload Docker image
      uses: actions/upload-artifact@v4
      with:
        name: docker-image
        path: image.tar.gz

  scan-image:
    runs-on: ubuntu-latest
    needs: test-and-build
    steps:
    # Checkout the repository
    - name: Checkout code
      uses: actions/checkout@v4

    # Download Docker image artifact
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: .

    # Load Docker image
    - name: Load Docker image
      run: |
        docker load < image.tar.gz

    # Install Trivy for static scanning
    - name: Install Trivy
      run: |
        sudo apt-get update
        sudo apt-get install -y wget
        wget https://github.com/aquasecurity/trivy/releases/download/v0.58.1/trivy_0.58.1_Linux-64bit.deb
        sudo dpkg -i trivy_0.58.1_Linux-64bit.deb

    # Run Trivy scan and save output in JSON and text formats
    - name: Run Trivy vulnerability scanner
      run: |
        trivy image --severity HIGH,CRITICAL --format json --output trivy_scan_result.json ${{ env.APP_NAME }}:${{ needs.test-and-build.outputs.image_tag }}
        trivy image --severity HIGH,CRITICAL --format table ${{ env.APP_NAME }}:${{ needs.test-and-build.outputs.image_tag }} > Trivy_scan_result.txt

    # Check CRITICAL vulnerabilities count and set exit code
    - name: Check CRITICAL vulnerabilities count
      run: |
        CRITICAL_COUNT=$(jq '[.Results[].Vulnerabilities[]? | select(.Severity == "CRITICAL")] | length' trivy_scan_result.json)
        echo "Found $CRITICAL_COUNT CRITICAL vulnerabilities"
        if [ "$CRITICAL_COUNT" -ge ${{ vars.QUALITY_GATE }} ]; then
          echo "Threshold of 10 CRITICAL vulnerabilities exceeded"
          exit 1
        fi

    # Upload Trivy scan result as artifact
    - name: Upload Trivy scan result
      uses: actions/upload-artifact@v4
      with:
        name: Trivy_scan_result
        path: Trivy_scan_result.txt

  push-to-azure-acr:
    runs-on: ubuntu-latest
    needs:
    - scan-image
    - test-and-build    
    permissions:
      id-token: write
      contents: read
    outputs:
      acr_address: ${{ steps.tag-and-push.outputs.acr_address }}
    steps:
    # Checkout the repository
    - name: Checkout code
      uses: actions/checkout@v4

    # Download Docker image artifact
    - name: Download Docker image
      uses: actions/download-artifact@v4
      with:
        name: docker-image
        path: .        

    # Load Docker image
    - name: Load Docker image
      run: |
        docker load < image.tar.gz

    # Authentication with Azure using OIDC
    - name: Login to Azure with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    # Login to Azure ACR authenticated via OIDC
    - name: Login to Azure ACR
      run: |
        az acr login --name ${{ env.ACR_NAME }}

    # Tag and push Docker image to ECR
    - name: Tag and push Docker image to ECR
      id: tag-and-push
      env:
        ACR_REGISTRY: ${{ env.ACR_NAME }}.azurecr.io
        ACR_REPOSITORY: ${{ env.ACR_REPO_NAME }}
        LATEST_TAG: latest
        IMAGE_TAG: ${{ needs.test-and-build.outputs.image_tag }}
      run: |
        echo ---------------------------        
        echo "acr_address=$ACR_REGISTRY"
        echo "acr_address=$ACR_REGISTRY" >> $GITHUB_OUTPUT
        docker tag ${{ env.APP_NAME }}:$IMAGE_TAG $ACR_REGISTRY/$ACR_REPOSITORY:$IMAGE_TAG 
        docker tag ${{ env.APP_NAME }}:$IMAGE_TAG $ACR_REGISTRY/$ACR_REPOSITORY:$LATEST_TAG
        docker push $ACR_REGISTRY/$ACR_REPOSITORY:$IMAGE_TAG
        docker push $ACR_REGISTRY/$ACR_REPOSITORY:$LATEST_TAG

  deploy:
    needs: 
      - scan-image
      - test-and-build
      - push-to-azure-acr
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    # Authentication with Azure using OIDC
    - name: Login to Azure with OIDC
      uses: azure/login@v2
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: Update WebApp contianer settings
      env:
        ACR_REPOSITORY: ${{ env.ACR_REPO_NAME }}
        IMAGE_TAG: ${{ needs.test-and-build.outputs.image_tag }}
      run: |
        az webapp config container set \
          -n ${{ env.WEBAPP_NAME }} \
          -g ${{ env.RESOURCE_GROUP }} \
          -c ${{ env.ACR_NAME }}.azurecr.io/${{ env.ACR_REPO_NAME }}:$IMAGE_TAG

    # Restart Web App to apply the new container image
    - name: Restart Web App
      run: |
        az webapp stop -n ${{ env.WEBAPP_NAME }} -g ${{ env.RESOURCE_GROUP }}
        sleep 20
        az webapp start -n ${{ env.WEBAPP_NAME }} -g ${{ env.RESOURCE_GROUP }}

  integration-testing:
    name: ENV Integration Testing
    needs: deploy
    runs-on: ubuntu-latest
    steps:
    - name: Test URL Output using curl and jq
      env:
        URL: ${{ vars.SITE_TEST_URL }}        # flexibility to use different hostname and dns-name during the test
        SITE_TEST_URL: ${{ vars.SITE_TEST_URL }}
      run: |
        retry_count=0
        MAX_RETRIES=10
        SLEEP_DURATION=60

        echo SITE_TEST_URL=$SITE_TEST_URL
        echo URL=$URL
        CURL_COMMAND="curl -s --header 'Host: $SITE_TEST_URL' https://$URL"
        
        while [ $retry_count -lt $MAX_RETRIES ]; do
          if $CURL_COMMAND; then
            curl -i --header "Host: $SITE_TEST_URL" https://$URL
            echo "\nCurl test succeeded!\nService status: "
            curl -s --header "Host: $SITE_TEST_URL" https://$URL/healthz | jq -r .status | grep -i healthy
            exit 0
          else
            echo "Curl command failed. Retry $((retry_count + 1))/$MAX_RETRIES after $SLEEP_DURATION seconds..."
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $MAX_RETRIES ]; then
              sleep $SLEEP_DURATION
            else
              echo "Max retries reached. Exiting with failure..."
              exit 1
            fi
          fi
        done
